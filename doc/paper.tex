\documentclass[twocolumn]{article}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{hyperref}
\title{Factoring with $n+2$ clean qubits and $n-1$ dirty qubits}
\author{Craig Gidney}

\begin{document}
\maketitle

\begin{abstract}
\em
We present reversible classical circuits for performing various arithmetic operations aided by dirty ancilla in an unknown state that must be preserved.
We improve the number of qubits needed to factor an $n$-bit number with Shor's algorithm \cite{Shor1999} from $2n+2$ qubits \cite{takahashi2006, haner2016} to $2n+1$ qubits, without increasing the asymptotic depth of the circuit.
We also allow $n-1$ of the $2n+1$ qubits to be dirty.
\end{abstract}

\section{Introduction} \label{sec:introduction}

When constructing quantum circuits, or classical reversible circuits, an important resource is the number of available ancilla.
An ancilla is an extra bit or qubit that is available for use by a circuit as temporary workspace.
Ancilla may be initialized to a known state (``clean bit"), or be given to the circuit in an unknown state (``dirty bit") that must be restored before the circuit finishes.
Clean bits are more valuable, allowing for simpler and more compact circuit constructions, but dirty bits are more plentiful, since any temporarily unused bit is a borrowable dirty bit.

One part of a circuit can borrow dirty bits from another part of the same circuit, so circuit constructions that require only dirty bits are easier to apply under tight space constraints, or on circuit topologies where other ancilla are too far away to be acquired quickly.
When attempting to reduce the number of bits or qubits required by a circuit, converting clean ancilla to dirty ancilla is a useful intermediate goal.
In this paper, at great cost to the constant factors in the gate count and depth, we reduce the number of qubits required to perform period finding on modular exponentiation from $2n+2$ clean qubits \cite{takahashi2006, haner2016} to $n+2$ clean qubits and $n-1$ dirty qubits without increasing the asymptotic costs.

Our paper is structured as follows.
Section \ref{sec:introduction} introduces and describes the conventions our circuit constructions will follow.
In section \ref{sec:construct} we describe the circuit constructions we use to convert period finding into constant-sized gates, while tracking the number of required dirty ancilla.
Then, in section \ref{sec:costs}, we discuss the novelty and comparative costs of the presented circuit constructions.
Finally, section \ref{sec:conclusion} concludes and summarizes.

All constructions in this paper use a 2s-complement representation of integers, and all diagrams order qubits from least significant bit (LSB) at the top to most significant bit (MSB) at the bottom.
Nearly all presented circuit constructions are classical, and the required dirty qubit counts we note and show in diagrams are in terms of those classical constructions.
The quantum trick shown in figure \ref{fig:bootstrap-ancilla} can cut dirty ancilla from several of our constructions, but only in places that don't affect the overall total for period-finding.

For clarity, circuit diagrams will divide operations into separate input and output parts, with inputs shaded gray, when applicable.
For completeness, even when the period finding reduction doesn't produce a controlled version of an operation, we nevertheless provide controllable constructions that scale linearly with the number of controls.
For brevity, we take for granted that each circuit's inverse operation is decomposed into the same operations as the original operation but run in reverse order and with each sub-operation inverted (a decrement is a reversed increment, a division is a reversed multiplication, and so forth).

We do not attempt to give reasonable behavior to modular arithmetic circuits applied to out of range values (ones equal to or larger than the modulus).
This {\em includes input values}.
For example, if our modular addition construction ($x \mathrel{{+}{=}} y \pmod{R}$) is applied to a $y \geq R$, then we don't guarantee that $y \mod R$ will be added into $x$ or that the operation will commute with other additions or that anything sensible at all will happen.
If the precondition $y < R$ is violated, what occurs is undefined behavior \cite{c11}.


\section{Period Finding into Toffolis} \label{sec:construct}

\subsection{Period Finding}

A high-level view of the circuit for period finding on modular exponentiation, the core quantum subroutine of Shor's quantum factoring algorithm \cite{Shor1999}, is shown in figure \ref{fig:period-finding}.
The circuit starts by preparing a uniform superposition $|\psi_0\rangle = \sqrt{2^{-n}} \sum_{k=0}^{2^n} |k\rangle$, then uses the $\times B^A {\pmod R}$ operation to separate that superposition into equivalence classes modulo the unknown period $p$ of said operation.
That is to say, w.l.o.g. the state ends up equal to $|\psi_{1,x}\rangle = \sqrt{2^{-n}/p} \sum_{k=0}^{2^n/p} |pk + x \rangle$ for some $x$.
The circuit then applies an inverse Fourier transform to the state.
Fourier transforming a uniform signal with period $p$ produces a spectrum with peaks near $N \cdot 0/p$, $N \cdot 1/p$, $N \cdot 2/p$, ..., $N \cdot (p-1)/p$.
Shor's algorithm recovers the period $p$ by sampling values $s_i$ from said spectrum, then using a continued fractions algorithm to compute the denominator of a fraction closest to $s_i/N$ given some maximum denominator.

Because period-finding measures all qubits immediately after performing a QFT, most of the transformed qubits can be measured earlier than shown.
In fact, each qubit can be measured so early that the next qubit needed for the QFT does not even need to be initialized yet!
Only one of the qubits in the phase-estimation register needs to be present at a time, and so the phase register can be reduced to a single repeatedly-used qubit \cite{beauregard2003}.
Figure \ref{fig:period-finding-solo-phase-qubit} shows a period-finding circuit with this property.
It uses (a) controlled modular multiplication, (b) measurement, (c) X-axis rotations classically parametrized by previous measurements, and (d) qubit resets.
Note that the only non-trivial operation is (a), the controlled modular multiplication of an $n$-qubit register.

We perform modular multiplication with multiply-accumulates and an ancilla register as in \cite{beauregard2003}.
However, to allow our ancilla register to be mostly dirty, we extend the operation so that it has a well defined effect on the second register: multiplying by the inverse factor.
We will refer to this combined multiply-A-and-inverse-multiply-B operation as a ``bimultiply".

The bimultiplications we perform throughout the algorithm do change the value of the ancilla register, but after the usual end of the circuit we can undo the damage.
The key insight is that the work register is initialized to $|1\rangle$ and gets multiplied by constants inverse to the ones trashing the dirty ancilla register.
Instead of discarding the work register after performing phase estimation, we measure it to recover the fixup factor needed to restore the dirty register's original value.
Figure \ref{fig:period-finding-solo-phase-qubit-explicit-dirty-register} shows this construction.

Because our modular circuit constructions would have undefined behavior if any register has a value equal to or larger than $R$, we need the ancilla register to contain a value less than $R$.
We ensure this by requiring that the ancilla register's MSB be $|0\rangle$ (i.e. clean) and that the registers be as small as possible (i.e. have size $n = \lceil \lg_2(R-1) \rceil$).

\begin{figure}
  \centering
  \makebox[\linewidth]{
    \includegraphics[width=\linewidth]{assets/shor-period-finding.png}
  }
  \caption{\em
	High-level period finding circuit \cite{Shor1999}.
	$R$ is the modulus being queried, $B$ is a randomly chosen base, $n$ is the number of bits needed to store $R$, and $p \in \Theta(n)$ controls the precision of the phase estimation step.
    The triangles indicate how many ancilla are needed ``behind the scenes", by our constructions, to perform an operation.
	Recovering the period requires classical post-processing of the sampled output.
  }
  \label{fig:period-finding}
\end{figure}

\begin{figure*}
  \centering
  \makebox[\linewidth]{
    \includegraphics[width=\linewidth]{assets/shor-period-finding-solo-phase-qubit.png}
  }
  \caption{\em
	Period finding with a single phase-estimation qubit \cite{beauregard2003}.
	The small oplus' ({\tiny $\oplus$}) are ``X-axis controls".
	An X-axis control is equivalent to a normal control, but with a Hadamard gate applied before and after.
	It conditions on the state $\frac{1}{\sqrt 2}|0\rangle - \frac{1}{\sqrt 2}|1\rangle$ instead of on the state $|1\rangle$.
  }
  \label{fig:period-finding-solo-phase-qubit}
\end{figure*}

\begin{figure*}
  \centering
  \makebox[\linewidth]{
    \includegraphics[width=\linewidth]{assets/shor-period-finding-solo-phase-qubit-double-register.png}
  }
  \caption{\em
	Period finding with a single phase-estimation qubit and paired inverse multiplications (``bimultiplications").
	Uses $O(n^3 \lg n)$ gates, $O(n^3)$ depth, and no additional qubits beyond those shown.
  }
  \label{fig:period-finding-solo-phase-qubit-explicit-dirty-register}
\end{figure*}


\subsection{Modular Bimultiplication}

As in \cite{beauregard2003}, we perform controlled modular multiplication with a second register and modular scaled-accumulate operations.
However, to allow the second register to be dirty, we use an additional scaled-accumulate as well as a negation operation.
See figure \ref{fig:controlled-modular-multiply} for the circuit diagram.

To show that the circuit works, suppose that the two registers start in the state $(a, b)$, working modulo $R$.
By scale-adding the first register times $K$ into the second register, the system advances to $(a, b+aK)$.
Then a scale-subtract times $K^{-1}$ out of the first register puts the system into the state $(a-bK^{-1}-aKK^{-1}, b+aK)$, which is just $(-bK^{-1}, b+aK)$.
Next, we cancel the $b$ term in the second register by scale-adding the first register times $K$ into it again, leaving $(-bK^{-1}, b+aK-bK^{-1} \cdot K)$ which is simply $(-bK^{-1}, aK)$.
Finally, we swap the terms and negate the second term to get $(aK, bK^{-1})$ as desired.

In the case where $K$ has no multiplicative inverse modulo $R$, this construction will not work (it would define an invalid irreversible operation).
However, that would mean $K$ is a factor of $R$; a case that the very lucky user can check for and handle classically before bothering to factor $R$ with a quantum computer.

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{assets/controlled-modular-multiply.png}
  \caption{\em
    Controlled modular bimultiplication, with a constant multiplier $K$, using three modular scaled-accumulates and a swap.
    $K$ must have a multiplicative inverse modulo $R$.
    Uses no ancilla, $O(c + n^2 \lg n)$ gates, and $O(c + n^2)$ depth where $c$ is the number of controls and $n$ is the register size.
  }
  \label{fig:controlled-modular-multiply}
\end{figure}


\subsection{Modular Scaled-Accumulation}

To perform scale-accumulate operations, we use a shift-and-add approach similar to \cite{beauregard2003}.
We right-shift (i.e. divide by $2 {\pmod R}$) the target register $n-1$ times, then begin iteratively left-shifting (i.e. multiplying by $2 {\pmod R}$) and adding $K$ into the target.
We condition the first modular addition on the most significant bit of the input, the second addition on the next most significant bit, and so forth.
(The more significant bits go first because their effects must be hit by more left-shifts.)
See figure \ref{fig:controlled-modular-scale-accumulate}.

The conditional offset and modular doubling operations need a dirty bit, but for non-trivial $n$ there are more than enough unused bits available to borrow, so the circuit as a whole doesn't require any dirty bits.

Note that the modular doublings require $R$ to be odd, since otherwise the operation would be irreversible.
However, given that in the intended use case $R$ is a number to be factored, it is reasonable to require callers to have factored out multiples of two beforehand.

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{assets/controlled-modular-multiply-accumulate.png}
  \caption{\em
    Reducing a controlled modular scale-accumulate, with a constant multiplier $K$, into the modular equivalent of shift-and-add.
    Requires the modulus $R$ to be odd.
    Uses no ancilla, $O(c + n^2 \lg n)$ gates, and $O(c + n^2)$ depth where $c$ is the number of controls and $n$ is the register size.
  }
  \label{fig:controlled-modular-scale-accumulate}
\end{figure}


\subsection{Modular Doubling}

To multiply a register by 2 modulo an odd $R$, we use controlled offsets and nots to align each half of the input state space against MSB boundaries.
Once that's done, a left-rotate completes the operation by turning the MSB into the LSB (converting the alignment into interleaving).
See figure \ref{fig:modular-double}.

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{assets/controlled-modular-double.png}
  \caption{\em
    Controlled modular doubling in $O(c + n \lg n)$ gates, $O(c + n)$ depth, with 2 dirty ancilla.
    $R$ must be odd.
    Uses 1 dirty ancilla, $O(c + n \lg n)$ gates, and $O(c + n)$ depth where $c$ is the number of controls and $n$ is the register size.
  }
  \label{fig:modular-double}
\end{figure}


\subsection{Modular Addition / Offset}

As shown in figure \ref{fig:mod-add-from-pivot-flip-bars}, a modular addition is three pivot-flips (see section \ref{sec:pivot-flips}).
To add $A$ into a register modulo $R$, perform pivot-flips with the pivot at $R-A$, then $R$, then $A$.
(The pivot-flip at $R$ can be simplified because the values above $R$ don't matter.)
See figure \ref{fig:controlled-modular-add} for the circuit.

Interestingly, modular addition can use its own controls as dirty bits that would otherwise be required.
For modular offset (i.e. adding a compile-time constant into a register), the two dirty bits are required whether or not the operation is controlled.
See figure \ref{fig:controlled-modular-offset}.

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{assets/mod-add-from-pivot-flip-bars.png}
  \caption{\em
     Modular addition of $A \pmod{R}$ can be done with three pivot flips.
     One at $R-A$, then one at $R$, then one at $A$.
     Requires $A \leq R$.
   }
  \label{fig:mod-add-from-pivot-flip-bars}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{assets/controlled-modular-addition.png}
  \caption{\em
    Controlled modular addition construction based on pivot-flips.
    Uses $2-c$ dirty ancilla, $O(c + n \lg n)$ gates, and $O(c + n)$ depth where $c$ is the number of controls and $n$ is the register size.
  }
  \label{fig:controlled-modular-add}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{assets/controlled-modular-offset.png}
  \caption{\em
    Controlled modular offset construction based on pivot-flips.
    Uses $2$ dirty ancilla, $O(c + n \lg n)$ gates, and $O(c + n)$ depth where $c$ is the number of controls and $n$ is the register size.
  }
  \label{fig:controlled-modular-offset}
\end{figure}


\subsection{Modular Negation}

To negate a number mod $R$, we need to reverse the order of the states $|1\rangle$ to $|R-1\rangle$.
We do so by temporarily moving $|0\rangle$ out the way with a decrement, pivot-flipping at $R-1$, then undoing the decrement.
See figure \ref{fig:negate-mod}.

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{assets/negate-mod.png}
  \caption{\em
    Controlled modular negation.
    Uses $2$ dirty ancilla, $O(c + n \lg n)$ gates, and $O(c + n)$ depth where $c$ is the number of controls and $n$ is the register size.
  }
  \label{fig:negate-mod}
\end{figure}


\subsection{Pivot-Flips} \label{sec:pivot-flips}

We implemented both modular negation and modular offset/addition in terms of a non-standard operation we call a ``pivot-flip".
A pivot-flip is an operation that reverses the order of states less than a given pivot value, without affecting other states.
For example, a pivot-flip with the pivot equal to 4 would swap $|0\rangle$ and $|3\rangle$, swap $|1\rangle$ and $|2\rangle$, and leave all other states untouched.

The exact permutation performed by a pivot-flip with pivot equal to $A$ is:

$$\text{PivotFlip}_A = \sum_{i=0}^{A-1} |A-i-1\rangle \langle i| + \sum_{i=A}^{N-1} |i\rangle \langle i|$$

To perform a pivot-flip efficiently, we use the fact that $x \rightarrow \lnot(x - A)$ nearly does what is required: it flips the range below $A$ but unfortunately also flips the range above-and-including $A$.
However, because $x \rightarrow \lnot(x - A)$ is its own inverse, the operation can be ``toggle-controlled'', where the operation undoes itself unless a controlling qubit is toggled between two applications.
Also, because the operation doesn't change whether any state is above or below the pivot, the controlling qubit can be toggled by a comparison of the target itself against the pivot (even though the target is being operated on).

See figures \ref{fig:controlled-pivot-flip} and \ref{fig:controlled-const-pivot-flip} for the circuit diagrams.
For states that are less than the pivot $A$, the comparison against the pivot keeps toggling the ancilla and exactly one of the controlled subtract-and-inverts will fire.
For other states, the ancilla does not change and so the subtract-and-inverse happens either no times or two times (undoing itself) for a net effect of no effect.

Note that, depending on whether or not the pivot is a compile-time constant or another qubit register, different subtraction constructions are used when reducing further.
This distinction matters because the constant-offset construction uses $O(n \lg n)$ gates \cite{haner2016} instead of the $\Theta(n)$ gates used by enregistered addition \cite{takahashi2005}.

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{assets/controlled-pivot-flip.png}
  \caption{\em
    Controlled pivot-flip circuit with an enregistered pivot.
    Uses $2$ dirty ancilla, $O(c + n \lg n)$ gates, and $O(c + n)$ depth where $c$ is the number of controls and $n$ is the register size.
  }
  \label{fig:controlled-pivot-flip}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{assets/controlled-const-pivot-flip.png}
  \caption{\em
    Controlled pivot-flip circuit with a constant pivot.
    Uses $2$ dirty ancilla, $O(c + n \lg n)$ gates, and $O(c + n)$ depth where $c$ is the number of controls and $n$ is the register size.
  }
  \label{fig:controlled-const-pivot-flip}
\end{figure}


\subsection{Comparison}

Comparison operations toggle a target bit based on the relationship between two input registers.
We implement comparisons as in \cite{takahashi2005}, using an addition followed by a slightly smaller subtraction that clears all changes except the overflow signal into the target bit.
For comparisons against another register this uses $1$ dirty ancilla (if controlled, otherwise no ancilla), $O(c + n)$ gates, and $O(c + n)$ depth.
For comparisons against a constant, the number of gates increases to $O(c + n \lg n)$ and the dirty ancilla is always required.

When dirty qubits are plentiful, the overflow-predicting construction from \cite{haner2016} with better constant factors can be used instead.


\subsection{Addition / Offset}

\cite{takahashi2005} provides a reversible adder circuit that uses $O(n)$ gates, $O(n)$ depth, and no ancilla.
We show an equivalent circuit in figure \ref{fig:inlineadder}.
Because the construction uses the input register as workspace, it doesn't work when the input is a compile-time constant or when the target register is larger than the input register.

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{assets/inline-adder.png}
  \caption{\em Adder for input and target registers of the same size.
  Requires no ancilla, and uses $O(N)$ gates and depth.
  Based on \cite{van2004, takahashi2005}.}
  \label{fig:inlineadder}
\end{figure}

When the value to be added into a register is a compile-time constant (i.e. when applying an offset gate), we use the offset construction from \cite{haner2016}.
Their offset circuit, shown in figure \ref{fig:offset}, uses $O(n \lg n)$ gates, $O(n)$ depth, and one dirty ancilla.

When the target register is larger than the input register, three increment/decrement tweaks to the same-register-size adder fix the insufficient-input-space problem without increasing asymptotic costs.
(Note that, to avoid cyclic dependencies, the increment and decrement constructions described in the next subsection will only use the same-register-size adder.)
First, the carry signal is forwarded into the high part of the target register with a controlled increment instead of with a CNOT.
Second, to free the MSB of the input register for use as a dirty ancilla holding the carry signal, we add it into the target ahead of time with a controlled increment.
Finally, when the MSB is on (instead of off) its role as carry signal causes an extra increment of the target.
This extra increment is cancelled with a controlled decrement.
See the circuit diagram in figure \ref{fig:inline-adder-into-large}.

To control addition gates, and offset gates, we do an uncontrolled addition followed by an uncontrolled subtraction bordered by NOT gates that fire when the controls are satisfied.
When the NOT gates don't fire, the subtraction cancels the addition.
When the NOT gates do fire, the subtraction is inverted into an addition and $2 \cdot A$ is added to the target.
To add $A$ instead of $2 \cdot A$ into the target, we temporarily prepend a dirty bit onto the target register.
See \ref{fig:controlled-addition}.

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{assets/offset.png}
  \caption{\em
      Offset circuit from \cite{haner2016}.
      Uses $1$ dirty ancilla, $O(n \lg n)$ gates, and $O(n)$ depth (by overlapping the recursive cases).
  }
  \label{fig:offset}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{assets/inline-adder-into-large.png}
  \caption{\em
      Adder with target larger than source, using no ancilla.
      Uses $O(n)$ gates and depth.
      The increment and decrement gates all have at least one free wire to borrow as a dirty ancilla.
  }
  \label{fig:inline-adder-into-large}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{assets/controlled-addition.png}
  \caption{\em
  	Reducing controlled addition to uncontrolled addition.
  	Uses $O(c + n)$ gates, $O(c + n)$ depth, and a dirty ancilla.
  	When applied to offset gates, uses $O(c + n \lg n)$ gates, $O(n + c)$ depth, and two dirty ancilla.
  }
  \label{fig:controlled-addition}
\end{figure}


\subsection{Increment}

A register can be incremented by subtracting both $x$ and $\neg x = -x-1$ from it, for any $x$.
When $n$ dirty bits are available, $x$ can come from a register defined by those $n$ arbitrary bits, as shown in figure \ref{fig:increment-many-dirty}.

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{assets/increment-many-dirty.png}
  \caption{\em Subtracting $x$ and $-x-1$ from a register increments it. Requires $O(N)$ depth, size, and $N$ dirty ancilla.}
  \label{fig:increment-many-dirty}
\end{figure}

To improve from $n$ dirty bits to a single dirty bit, we break the increment operation into two halves.
A high half that is incremented only if all of the bottom bits are on, and a low half that is unconditionally incremented.
The low half can be incremented with the double-subtraction trick by borrowing the high half.
But the double-subtraction trick doesn't work on the high half, because the low half can't be borrowed when it is being used as a control.

To work around not being able to operate on the borrowed bits while using them as a control, start with the double-subtraction trick but change the second subtraction to an addition and conditionally toggle the target bits instead of the input bits.
When the condition isn't satisfied, the addition and subtraction will cancel each other.
When the condition is satisfied, the addition will be inverted into a subtraction, and both the subtraction and addition-turned-subtraction will fire, subtracting the input register from the target register twice.
However, because we are conditioning on the input bits all being on, we know the input must be -1.
Therefore the target was incremented by 2.
To halve the +2 into a +1, prepend a dirty least-significant-bit onto the target register.

Note that, to avoid a cyclic dependency, we must require that the additions and subtractions use input and target registers of the same size.
So the construction described in the previous paragraph only works for odd-sized registers.
For even-sized registers, we simply handle the LSB separately.
Also, we support controls with another conditional-inversion trick.
See figure \ref{fig:controlled-increment-odd}.

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{assets/controlled-increment-odd.png}
  \caption{\em
    Odd-sized controlled increment.
    For the even-sized case, separate the LSB from the rest of the register, increment the rest of the register using the LSB as an extra control, then toggle the LSB.
    Uses $O(c+n)$ gates, $O(c+n)$ depth, and 1 dirty ancilla.
  }
  \label{fig:controlled-increment-odd}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{assets/ancilla-bootstrap.png}
  \caption{\em Bootstrapping a dirty ancilla out of an increment gate using quantum operations.
  The $i^{\text{frac}}$ gate is a ``phase gradient" operation that phases each computational basis state $|v\rangle$ by an amount proportional to $v/2^d$, where $d$ is the size of the register.
  In this case each state is phased by $e^{i \frac{\pi}{2} v/2^d}$.
  The phase gradient is implemented by a column of $Z^{2^{-k}}$ gates, .}
  \label{fig:bootstrap-ancilla}
\end{figure}


\subsection{Bit Swaps, Rotations, and Reversals}

Bit permuting operations can usually be emulated by re-labelling qubits, so they are easy to overlook in circuits.
But some of our circuit diagrams have used controlled bit rotations, requiring actual operations, so we provide the constructions in figures \ref{fig:bit-rotate} and \ref{fig:bit-reverse} for completeness.

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{assets/controlled-bit-rotate.png}
  \caption{\em
    A controlled bit rotation / bit swap is three controlled bit-reverses.
    Uses no ancilla, $O(n+c)$ gates, and $O(n+c)$ depth.
  }
  \label{fig:bit-rotate}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{assets/controlled-reverse.png}
  \caption{\em
    An inline controlled bit order reversal.
    Each XOR operation is a series of independent CNOTs (note that the inputs have opposite endian-ness to the outputs).
    For reversals on an even number of bits, swap the center two bits beforehand then use one of them as the center workspace bit from this construction.
    Uses no ancilla, $O(c + n)$ gates, and $O(c + n)$ depth.
  }
  \label{fig:bit-reverse}
\end{figure}


\subsection{Multi-Nots}

Several of our constructions have used CNOTs with many controls and many targets.
To avoid paying the overhead of $c$ controls for every target, we use one big CNOT to toggle-control all the others.
We then use a dirty ancilla (i.e. one of the other targets) to efficiently reduce the big CNOT into Toffolis.


\section{Overview and Improvements} \label{sec:costs}

In figure \ref{fig:dependencies} we show a dependency graph of the constructions discussed in this paper.
The total cost of period-finding, using the full construction, is $O(n^3 \lg n)$ gates and $O(n^3)$ depth.
We perform $O(n)$ modular multiplications, each of which uses $O(n)$ modular additions and offsets, each of which uses $O(n \lg n)$ gates \cite{haner2016} and $O(n)$ depth.

We tested individual constructions in \href{https://github.com/Strilanc/Quirk}{Quirk} and the full construction down to Toffoli gates in \href{https://github.com/ProjectQ-Framework/ProjectQ}{ProjectQ} \cite{projq2016}.
The source code, and an issue tracker for submitting errata, can be found at \href{https://github.com/Strilanc/PaperImpl-PeriodFindCutQubits}{github.com/Strilanc/PaperImpl-PeriodFindCutQubits}.
[[[ maybe make a plot of gate counts vs size? ]]] [[[ definitely need another constant-factor joke ]]]

Our main improvements over previous constructions are 1) the use of pivot-flips for modular addition, 2) the use of bimultiplication for modular multiplication, and 3) the $O(n)$ incrementer requiring only a single dirty ancilla.

Previous modular addition constructions worked by temporarily storing an is-wraparound-needed comparison in a clean ancilla \cite{takahashi2006, haner2016}.
Pivot flips also require ancilla (two, actually), but the ancilla can be dirty and, in the context of period-finding, there's always qubits available to borrow whenever a pivot-flip is needed.
This improvement saves a qubit in the overall circuit, reducing the total number of qubits required for period finding (on modular exponentiation against an $n$-bit modulus) from $2n+2$ to $2n+1$.

Previous modular multiplication constructions required a clean ancilla register \cite{haner2016}.
We use an an extra multiply-accumulate and negation to prevent the ancilla register from leaking into the work register, and add a clean-up multiplication informed by the work register at the end of the circuit to undo any effects on the ancilla register.
This improvement allows $n-1$ of the qubits in the ancilla register to be dirty (only the MSB must be zero; to ensure the register's value is in range).

Previous published incrementers (not counting an unpublished version of our construction \cite{gidney2015} cited by \cite{haner2016}) required either $O(n^2)$ gates or $\omega(1)$ ancilla \cite{draper2000, barenco1995}.
Our classical incrementer constructions use $O(n)$ gates and a single dirty ancilla.
Note that, for classical reversible computation, 1 dirty ancilla is optimal.
The parity of the state permutation performed by an increment operation is odd, but the parity of the permutation performed by any classical gate that doesn't cover the entire circuit is even.
When quantum operations are available, the final ancilla can be cut without increasing the asymptotic cost (see figure \ref{fig:bootstrap-ancilla}).

\begin{figure}
  \centering
  \includegraphics[height=17.3cm]{assets/dependencies.png}
  \caption{
    Meta-figure showing the transitive reduction of dependencies between constructions in our paper.
    Edge labels indicate which constructions use a dependency more than a constant number of times.
  }
  \label{fig:dependencies}
\end{figure}


\section{Future Work and Conclusion} \label{sec:conclusion}

Of the $2n+1$ qubits our period-finding construction requires: $1$ is used for the phase estimation qubit, $n$ are used to store the work register, and $n$ are ancilla used to implement modular multiplication in terms of scaled modular addition.
All the other constructions, for simpler arithmetic, need two or fewer dirty ancilla.
Furthermore, because scaled modular addition is reduced into operations that have a $\Theta(n)$ surplus of unused qubits, in context there's always more than enough dirty ancilla available to implement the simpler arithmetic inline.
There's so much slack in the simpler arithmetic constructions that improving the number of qubits used by period-finding effectively means improving the very first step, from multiplication to some other operation, and nothing else.

For example, consider a situation where we could cut multiplication operations into two pieces.
If we knew the factorization $p \cdot q$ of the modulus $R$, with $p$ and $q$ each having size $\approx n/2$, then the Chinese remainder theorem guarantees we could uniquely represent $x \mod R$ as the pair $(x \mod p, x \mod q)$.
Multiplications of the half-sized values could use and re-use the same half-sized clean ancilla register, so there would be three half-sized registers (one for $x \mod p$, one for $x \mod q$, and one ancilla register) for a total qubit count of $\approx 1.5n$.
Despite the large reduction in the number of ancilla available to them, the underlying constructions would still contribute no additional ancilla.
(Note: because the initial value $x_0 = 1$ is trivial, and the final value is discarded, it's not necessary to implement circuits that translate between the Chinese-remainder representation and the usual 2s-complement representation.)
Of course, since we use period-finding to compute the factorization of $R$, using the factorization of $R$ to optimize period-finding would be paradoxical.

We presented Toffoli-based arithmetic circuits that reduce the smallest known number of qubits required to perform Shor's algorithm from $2n+2$ to $2n+1$.
The constructions also reduce the number of {\em clean} qubits required by $n$, so the number of clean qubits required is now $n + O(1)$.
We consider this to be a step towards a period-finding construction that uses only $n + O(1)$ qubits total, which could reduce the expected lifetime of current cryptographic keys by years (depending on how quickly quantum computers gain error-corrected capacity).


\bibliographystyle{plain}
\bibliography{citations}

\end{document}
